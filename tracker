#! /usr/bin/perl -w

use strict;
use JSON;
use LockFile::Simple qw(lock unlock);

my $version='0.06';

my $cfg=$ARGV[0] || 'tracker.cfg';
my %config;
{
  open (IN,"<$cfg") || die "no config file $cfg\n";
  binmode IN;
  my $st=join('',<IN>);
  close IN;
  if ($st) {
    %config=%{decode_json($st)};
  }
  my $d=0;
  foreach my $re (qw(port statefile interval allowed expiry)) {
    unless (exists $config{$re}) {
      warn "$re undefined in config\n";
      $d=1;
    }
  }
  if ($d) {
    die "Aborting startup\n";
  }
}

{
  package NoBrakeTracker;

  use HTTP::Server::Simple::CGI;
  use base qw(HTTP::Server::Simple::CGI);
  use JSON;
  use File::Find;
  use Digest::SHA1 qw(sha1);
  use Clone qw(clone);
  use List::Util qw(shuffle);
  use Convert::Bencode_XS qw(bencode bdecode);
  use Regexp::IPv6 qw($IPv6_re);
  use Net::IPv6Addr;
  use LockFile::Simple qw(lock unlock);

  my $IPv4_re='\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}';
  my $nextsave=time+$config{min_save};
  my $dirty=0;

  my %dispatch = (
    '/announce' => \&resp_tracker
  );

  if (!exists $config{noscrape}) {
    $dispatch{'/stats'}=\&resp_stats;
    $dispatch{'/scrape'}=\&resp_scrape;
  }

  my %state;
  my %config;
  my $fh;

  sub config {
    my $self=shift;
    my $c=shift;
    %config=%{$c};
    if (exists $config{logfile}) {
      open ($fh,">>$config{logfile}") || die "Can't open logfile $config{logfile}\n";
    } else {
      $fh=*STDERR;
    }
    autoflush $fh 1;
    print $fh join(' ',scalar localtime,
                       'startup'),"\n";
  }

  sub handle_request {
    my $self = shift;
    my $cgi  = shift;

    my $path = $cgi->path_info();
    my $handler = $dispatch{$path};

    if (ref($handler) eq "CODE") {
      $handler->($cgi);
    } else {
      simple_return($cgi,404,'Not found');
    }
  }

  sub resp_tracker {
    my $cgi  = shift;
    return if !ref $cgi;

    my %data=map{$_ => scalar $cgi->param($_)} $cgi->param;
    map {delete $data{$_}} qw(ip4 port4 ip6 port6);
    $data{connip}=$cgi->remote_host;
    if (exists $data{ipv6} && $data{ipv6} =~ /^($IPv6_re)(?::(\d+))?/) {
      # valid ipv6 parameter given
      $data{ip6}=$1;
      $data{port6}=$2 || $data{port};
    } elsif ($data{connip} =~ /^$IPv6_re$/) {
      # no valid ipv6, but have v6 connection source
      $data{ip6}=$data{connip};
      $data{port6}=$data{port};
    }
    if (exists $data{ip} && $data{ip} =~ /^$IPv4_re$/) {
      # valid ipv4 parameter given
      $data{ip4}=$data{ip};
      $data{port4}=$data{port};
    } elsif (exists $data{ipv4} && $data{ipv4} =~ /^($IPv4_re)(?::(\d+))?/) {
      # valid ip parameter given (standard BT)
      $data{ip4}=$1;
      $data{port4}=$2 || $data{port};
    } elsif ($data{connip} =~ /^$IPv4_re$/) {
      # IPv4 connection source
      $data{ip4}=$data{connip};
      $data{port4}=$data{port};
    }
    if (!exists $data{ip4} && $data{ip6} =~ /^::ffff:($IPv4_re)$/) {
      # if we've bound v6, v4 source addresses will look like this
      $data{ip4}=$1;
      $data{port4}=$data{port6};
    }
    unless (exists $data{numwant}) {
      $data{numwant}=50;
    }
    if (my $c=$cgi->user_agent) {
      $data{user_agent}=$c;
    }
    unless (exists $data{peer_id} && $data{info_hash}) {
      bencoded_return($cgi,400,'Bad request',{'failure reason' => 'What?'});
      return;
    }

    unless ($config{allowed} eq '*' || exists $state{$data{info_hash}}) { # valid hash
      bencoded_return($cgi,403,'Forbidden',{'failure reason' => 'No such torrent here'});
      return;
    }

    if (exists $state{$data{info_hash}}{peer}{$data{peer_id}}) { # we've seen you before
      if (exists $state{$data{info_hash}}{peer}{$data{peer_id}}{left} &&
          $state{$data{info_hash}}{peer}{$data{peer_id}}{left} > 0 &&
          exists $data{left} &&
          $data{left} == 0) { # but you're now seeding
        $state{$data{info_hash}}{completed}++;
      }
    }
    $data{lastupdate}=time;
    if (exists $data{event} &&
        $data{event} eq 'stopped') {
      delete $state{$data{info_hash}}{peer}{$data{peer_id}};
    } else {
      $state{$data{info_hash}}{peer}{$data{peer_id}}=\%data;
    }

    if (time >= $nextsave) {
      lock($config{statefile});
      &save;
      unlock($config{statefile});
    }

    print $fh join(' ',scalar localtime,
                       'client',
		       $data{connip},
                       hexify($data{peer_id}),
                       $data{event} || 'no_event'),"\n";

    my %out=(interval => $config{interval},
             complete => 0,
             incomplete => 0);
    my @seeds;
    foreach my $p (keys %{$state{$data{info_hash}}{peer}}) {
      if ($state{$data{info_hash}}{peer}{$p}{lastupdate}+$config{expiry} < time) {
        delete $state{$data{info_hash}}{peer}{$p};
      } else {
        if ($state{$data{info_hash}}{peer}{$p}{left}==0) {
          $out{complete}++;
          push @seeds,$p;
        } else {
          $out{incomplete}++;
        }
      }
    }
    my $peers=clone $state{$data{info_hash}}{peer};
    my $excess=(scalar keys %{$peers}) - $data{numwant};
    if ($excess > 0 && $data{left}==0) {
      # you want fewer peers than I have and you're a seeder
      # let's trim some of the other seeds first
      @seeds=shuffle @seeds;
      while ($excess>0 && @seeds) {
        delete $peers->{pop @seeds};
        $excess--;
      }
    }
    if ($excess > 0) {
      # you still want fewer peers than I have; I'll drop them randomly.
      my @k=shuffle keys %{$peers};
      while ($excess>0 && %{$peers}) {
        delete $peers->{pop @k};
        $excess--;
      }
    }
    if (exists $data{compact} && $data{compact}==1) {
      my $p4='';
      my $p6='';
      foreach my $p (keys %{$peers}) {
        if (exists $peers->{$p}{ip4}) {
          $p4 .= pack('C*',split /\./,$peers->{$p}{ip4});
          $p4 .= pack('n',$peers->{$p}{port4});
        }
        if (exists $peers->{$p}{ip6}) {
          my $ip=Net::IPv6Addr->new($peers->{$p}{ip6});
          $p6 .= pack('n8',$ip->to_intarray);
          $p6 .= pack('n',$peers->{$p}{port6});
        }
      }
      $out{peers}=$p4;
      $out{peers6}=$p6;
    } else {
      my @p;
      foreach my $p (keys %{$peers}) {
        if (exists $peers->{$p}{ip4}) {
          push @p,{'peer id' => $p,
                   ip        => $peers->{$p}{ip4},
                   port      => $peers->{$p}{port4}};
        }
        if (exists $peers->{$p}{ip6}) {
          push @p,{'peer id' => $p,
                   ip        => $peers->{$p}{ip6},
                   port      => $peers->{$p}{port6}};
        }
      }
      $out{peers}=\@p;
    }
    if ($data{connip} =~ /^$IPv4_re$/) {
      $out{'external ip'}=pack('C*',split /\./,$data{connip});
    }


    print "HTTP/1.0 200 OK\r\n",
          $cgi->header('text/plain'),
          bencode(\%out);
  }

  sub resp_stats {
    my $cgi  = shift;
    return if !ref $cgi;

    my %data=map{$_ => scalar $cgi->param($_)} $cgi->param;
    print "HTTP/1.0 200 OK\r\n",
          $cgi->header,
          $cgi->start_html('Stats');
    print $fh join(' ',scalar localtime,
                       'stats',
		       $cgi->remote_host),"\n";
    my @rows;
    my @ih;
    if (exists $data{info_hash}) {
      if (exists $state{$data{info_hash}}) {
        @ih=($data{info_hash});
      } else {
        
      }
    } else {
      @ih=sort keys %state;
    }
    foreach my $digest (@ih) {
      if (exists $state{$digest}{secret} &&
          $state{$digest}{secret}==1 &&
          (!exists $data{info_hash} || $data{info_hash} ne $digest)) {
        # this is a secret torrent - don't report it in the general list
        # but if we have an info_hash request, we still report
      } else {
        push @rows,$cgi->td(['name' => $state{$digest}{name}]),
                   $cgi->td([size => $state{$digest}{size}]),
                   $cgi->td([completed => $state{$digest}{completed}]);
        my @pr=$cgi->th([qw(ip complete up down agent)]);
        foreach my $p (keys %{$state{$digest}{peer}}) {
          my $complete=int(100*(1-$state{$digest}{peer}{$p}{left}/$state{$digest}{size}));
          my %ip;
          foreach my $k (qw(connip ip4 ip6)) {
            if (exists $state{$digest}{peer}{$p}{$k}) {
              $ip{$state{$digest}{peer}{$p}{$k}}=1;
            }
          }
          my $ip=join('/',sort keys %ip);
          push @pr,$cgi->td([$ip,
                             $complete,
                             $state{$digest}{peer}{$p}{uploaded},
                             $state{$digest}{peer}{$p}{downloaded},
                             $state{$digest}{peer}{$p}{user_agent}]);
        }
        if (scalar @rows > 1) {
          push @rows,$cgi->td(['peers',$cgi->table($cgi->Tr(\@pr))]);;
        }
      }
    }
    print $cgi->table($cgi->Tr(\@rows));
    print $cgi->end_html;
  }

  sub resp_scrape {
    my $cgi  = shift;
    return if !ref $cgi;

    my %data=map{$_ => scalar $cgi->param($_)} $cgi->param;
    print $fh join(' ',scalar localtime,
                       'scrape',
		       $cgi->remote_host),"\n";
    my %out;

    my @ih;
    if (exists $data{info_hash}) {
      if (exists $state{$data{info_hash}}) {
        @ih=($data{info_hash});
      } else {
        
      }
    } else {
      @ih=sort keys %state;
    }
    foreach my $digest (@ih) {
      if (exists $state{$digest}{secret} &&
          $state{$digest}{secret}==1 &&
          (!exists $data{info_hash} || $data{info_hash} ne $digest)) {
        # this is a secret torrent - don't report it in the general list
        # but if we have an info_hash request, we still report
      } else {
        my %info=(downloaded => $state{$digest}{completed},
                  complete => 0,
                  incomplete => 0,
                  downloaders => 0);
        foreach my $p (keys %{$state{$digest}{peer}}) {
          if ($state{$digest}{peer}{$p}{left}==0) {
            $info{complete}++;
          } else {
            $info{incomplete}++;
            unless (exists $state{$digest}{peer}{$p}{upload_only} &&
                    $state{$digest}{peer}{$p}{upload_only}==1 &&
                    exists $state{$digest}{peer}{$p}{event} &&
                    exists $state{$digest}{peer}{$p}{event} eq 'paused') {
              $info{downloaders}++;
            }
          }
        }
        $out{$digest}=\%info;
      }
    }

    print "HTTP/1.0 200 OK\r\n",
          $cgi->header('text/plain'),
          bencode(\%out);
  }

  sub restore {
    open (IN,"<$config{statefile}") || return;
    binmode IN;
    my $st=join('',<IN>);
    close IN;
    if ($st) {
      %state=%{decode_json($st)};
    }
  }

  sub save {
    my $st=encode_json(\%state);
    open (OUT,">$config{statefile}") || return;
    print OUT $st;
    close OUT;
    $nextsave=time+$config{min_save};
  }

  sub scan {
    my $cgi  = shift;
    if ($config{allowed} eq '*') {
      return;
    }
    my @tfiles;
    find(sub{
      if (! -d $_ &&
          /\.torrent$/i) {
        push @tfiles,$File::Find::name;
      }
    },$config{allowed});
    my %found;
    foreach my $file (@tfiles) {
      my $secret=0;
      if ($file =~ /\.secret\.torrent$/i) {
        $secret=1;
      }
      open (I,"<$file") || next;
      binmode I;
      my $raw=join('',<I>);
      close I;
      my $d=bdecode($raw);
      my $size=1;
      if (exists $d->{info}{files}) {
        $size=0;
        foreach my $k (@{$d->{info}{files}}) {
          $size+=$k->{length};
        }
      } else {
        $size=$d->{info}{length} || 1;
      }
      my $ih=sha1(bencode($d->{info}));
      my $name=$d->{info}{name} || hexify($ih);
      $found{$ih}=[$size,$secret,$name];
    }
    foreach my $f (keys %found) {
      unless (exists $state{$f}) {
        $state{$f}={size => $found{$f}[0],
                    completed => 0,
                    name => $found{$f}[2],
                    secret => $found{$f}[1]};
	print $fh join(' ',scalar localtime,
                	   'torrent',
                	   hexify($f),
                	   'added'),"\n";
      }
    }
    foreach my $f (keys %state) {
      unless (exists $found{$f}) {
        delete $state{$f};
	print $fh join(' ',scalar localtime,
                	   'torrent',
			   hexify($f),
                	   'deleted'),"\n";
      }
    }
    &save;
  }

  sub simple_return {
    my ($cgi,$status,$text)=@_;
    print "HTTP/1.0 $status $text\r\n",
          $cgi->header,
          $cgi->start_html($text),
          $cgi->h1($text),
          $cgi->end_html;
  }

  sub bencoded_return {
    my ($cgi,$status,$text,$hash)=@_;
    print "HTTP/1.0 $status $text\r\n",
          $cgi->header('text/plain'),
          bencode($hash);
  }

  sub hexify {
    my $value=shift;
    my @shorts=unpack('n10',$value);
    return join('',map {sprintf('%04X',$_)} @shorts);
  }

  sub print_banner {
  }

}

my $nbt = NoBrakeTracker->new($config{port});
if (exists $config{ip}) {
  $nbt->host($config{ip});
}
if (exists $config{family} && $config{family} eq 'AF_INET6') {
  $nbt->family(Socket::AF_INET6);
}
unless (exists $config{min_save}) {
  $config{min_save}=0;
}
$nbt->config(\%config);
lock($config{statefile});
$nbt->restore;
unlock($config{statefile});
$nbt->scan;
if (exists $config{pidfile}) {
  my $pid=$nbt->background;
  open (PID,">$config{pidfile}") || die "Can't open $config{pidfile} to record pid $pid\n";
  print PID "$pid\n";
  close PID;
} else {
  $nbt->run;
}
